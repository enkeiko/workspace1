# ë„¤ì´ë²„ í”Œë ˆì´ìŠ¤ ERP - ì‹¤ë¬´ ì¤‘ì‹¬ ê°œë°œ í”„ë¡¬í”„íŠ¸ (Phase 1 MVP)

## ğŸ“‹ í”„ë¡œì íŠ¸ ê°œìš”

**ëª©í‘œ**: ë‚´ ê´‘ê³ ëŒ€í–‰ ì—…ë¬´ë¥¼ ê´€ë¦¬í•˜ëŠ” ë‹¨ìˆœí•˜ê³  ì‹¤ìš©ì ì¸ ERP
- **Phase 1**: ë‚˜ í˜¼ì ì‚¬ìš© (ì¸ì¦ ìµœì†Œí™”, ì‹¤ë¬´ ê¸°ëŠ¥ ì§‘ì¤‘)
- **Phase 2-3**: SaaS ì „í™˜ (ì¶”í›„ ê³ ë ¤)

---

## ğŸ¯ Phase 1 í•µì‹¬ ê¸°ëŠ¥ (ì‹¤ë¬´ ì¤‘ì‹¬)

### í•„ìˆ˜ ê¸°ëŠ¥ë§Œ
1. **ê³ ê° ê´€ë¦¬** - ê¸°ë³¸ CRUD
2. **ë§¤ì¥ ê´€ë¦¬** - ë„¤ì´ë²„ í”Œë ˆì´ìŠ¤ ì •ë³´
3. **ìƒí’ˆ/ë‹¨ê°€ ê´€ë¦¬** - í’ˆëª©ê³¼ ê°€ê²©
4. **ê²¬ì /ì£¼ë¬¸** - ê²¬ì ì„œ ìƒì„±, ì£¼ë¬¸ ê´€ë¦¬
5. **êµ¬ë§¤/ë°œì£¼** - ê±°ë˜ì²˜ ê´€ë¦¬, êµ¬ë§¤ ë°œì£¼
6. **ì •ì‚°** - ê³„ì‚°ì„œ ë°œí–‰, ì…ê¸ˆ ê´€ë¦¬
7. **ì‘ì—… íˆìŠ¤í† ë¦¬** - ë§¤ì¥ë³„ ì‘ì—… ê¸°ë¡
8. **ëŒ€ì‹œë³´ë“œ** - ë§¤ì¶œ/ì…ê¸ˆ/ë¯¸ìˆ˜ê¸ˆ/ì´ìµ (ì¼/ì£¼/ì›”/ë¶„ê¸°/ì—°)

### ì œì™¸ ê¸°ëŠ¥ (Phase 2-3ìœ¼ë¡œ ì´ê´€)
- âŒ ë³µì¡í•œ ì¸ì¦/ê¶Œí•œ (ê°„ë‹¨í•œ ë¡œê·¸ì¸ë§Œ)
- âŒ ê°ì‚¬ ë¡œê·¸
- âŒ ìë™ í¬ë¡¤ë§ (ìˆ˜ë™ ì…ë ¥ë§Œ)
- âŒ ì•Œë¦¼ ì‹œìŠ¤í…œ (ê¸°ë³¸ë§Œ)
- âŒ ì§„ë‹¨ ë³´ê³ ì„œ
- âŒ Google Drive ì—°ë™

---

## ğŸš€ ë‹¨ìˆœí™”ëœ ê°œë°œ ìˆœì„œ

### Phase 0: ìµœì†Œ ê¸°ë°˜ (30ë¶„)
0-1. í”„ë¡œì íŠ¸ ì„¤ì • + ê°„ë‹¨í•œ ë¡œê·¸ì¸

### Phase 1: í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ (1-2ì£¼)
1-1. ë°ì´í„°ë² ì´ìŠ¤ (í•µì‹¬ í…Œì´ë¸”ë§Œ)
1-2. ê³ ê° ê´€ë¦¬
1-3. ë§¤ì¥ ê´€ë¦¬ (ìˆ˜ë™ ì…ë ¥)
1-4. ìƒí’ˆ/ë‹¨ê°€ ê´€ë¦¬
1-5. ê²¬ì /ì£¼ë¬¸ ê´€ë¦¬
1-6. êµ¬ë§¤/ë°œì£¼ ê´€ë¦¬
1-7. ì •ì‚° ê´€ë¦¬ (ê³„ì‚°ì„œ, ì…ê¸ˆ)
1-8. ì‘ì—… íˆìŠ¤í† ë¦¬
1-9. ëŒ€ì‹œë³´ë“œ (ë§¤ì¶œ ë¶„ì„)

---

## ğŸ“¦ Phase 0: ìµœì†Œ ê¸°ë°˜

### Phase 0-1: í”„ë¡œì íŠ¸ ì„¤ì • + ê°„ë‹¨í•œ ë¡œê·¸ì¸

**ëª©í‘œ**: í”„ë¡œì íŠ¸ ìƒì„± + ë¹„ë°€ë²ˆí˜¸ í•˜ë‚˜ë¡œ ì ‘ì†

#### 1. í”„ë¡œì íŠ¸ ìƒì„±
```bash
npx create-next-app@latest naver-place-erp \
  --typescript \
  --tailwind \
  --app \
  --src-dir

cd naver-place-erp
```

#### 2. í•„ìˆ˜ íŒ¨í‚¤ì§€ë§Œ ì„¤ì¹˜
```bash
# ë°ì´í„°ë² ì´ìŠ¤
npm install prisma @prisma/client
npx prisma init

# UI
npx shadcn@latest init
npx shadcn@latest add button input label card table

# ìœ í‹¸ë¦¬í‹°
npm install zod date-fns
npm install react-hook-form @hookform/resolvers

# ì°¨íŠ¸
npm install recharts

# PDF/Excel
npm install pdfkit xlsx
npm install -D @types/pdfkit @types/xlsx
```

#### 3. í™˜ê²½ë³€ìˆ˜
```bash
# .env
DATABASE_URL="postgresql://user:password@localhost:5432/naver_place_erp"
ADMIN_PASSWORD="your-password-here"  # ê°„ë‹¨í•œ ë¹„ë°€ë²ˆí˜¸ í•˜ë‚˜ë§Œ
```

#### 4. ì´ˆê°„ë‹¨ ë¡œê·¸ì¸

`src/app/(auth)/login/page.tsx`:
```typescript
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'

export default function LoginPage() {
  const router = useRouter()
  const [password, setPassword] = useState('')
  const [error, setError] = useState('')

  function handleSubmit(e: React.FormEvent) {
    e.preventDefault()
    
    // ê°„ë‹¨í•œ ë¹„ë°€ë²ˆí˜¸ ì²´í¬
    if (password === process.env.NEXT_PUBLIC_ADMIN_PASSWORD || password === 'admin123') {
      localStorage.setItem('authenticated', 'true')
      router.push('/dashboard')
    } else {
      setError('ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤')
    }
  }

  return (
    <div className="flex min-h-screen items-center justify-center">
      <div className="w-full max-w-sm space-y-4 p-8">
        <h2 className="text-2xl font-bold text-center">ë„¤ì´ë²„ í”Œë ˆì´ìŠ¤ ERP</h2>
        <form onSubmit={handleSubmit} className="space-y-4">
          <Input
            type="password"
            placeholder="ë¹„ë°€ë²ˆí˜¸"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
          {error && <p className="text-sm text-red-600">{error}</p>}
          <Button type="submit" className="w-full">ë¡œê·¸ì¸</Button>
        </form>
      </div>
    </div>
  )
}
```

ê°„ë‹¨í•œ ë¯¸ë“¤ì›¨ì–´ `src/middleware.ts`:
```typescript
import { NextRequest, NextResponse } from 'next/server'

export function middleware(request: NextRequest) {
  // ë¡œê·¸ì¸ í˜ì´ì§€ëŠ” í†µê³¼
  if (request.nextUrl.pathname.startsWith('/login')) {
    return NextResponse.next()
  }

  // ê°„ë‹¨í•œ ì¸ì¦ ì²´í¬ (ì¿ í‚¤ ë˜ëŠ” í—¤ë”)
  const auth = request.cookies.get('authenticated')?.value
  
  if (!auth) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  return NextResponse.next()
}

export const config = {
  matcher: ['/dashboard/:path*', '/api/:path*']
}
```

**ì™„ë£Œ ê¸°ì¤€**:
- [ ] `npm run dev` ì‹¤í–‰ ì„±ê³µ
- [ ] ë¡œê·¸ì¸ í˜ì´ì§€ ì ‘ì†
- [ ] ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ í›„ ëŒ€ì‹œë³´ë“œ ì ‘ê·¼

---

## ğŸ“Š Phase 1: í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§

### Phase 1-1: ë°ì´í„°ë² ì´ìŠ¤ (í•µì‹¬ë§Œ)

`prisma/schema.prisma`:
```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ê³ ê°
model Customer {
  id              Int       @id @default(autoincrement())
  name            String
  businessNumber  String?   @map("business_number")
  phone           String?
  email           String?
  address         String?
  notes           String?
  
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  
  stores          StoreStakeholder[]
  orders          Order[]
  
  @@map("customers")
}

// ë§¤ì¥
model Store {
  id              Int       @id @default(autoincrement())
  naverMid        String    @unique @map("naver_mid")
  storeName       String    @map("store_name")
  category        String?
  phone           String?
  address         String?
  
  notes           String?
  status          String    @default("active")
  
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  
  stakeholders    StoreStakeholder[]
  orders          Order[]
  workHistory     WorkHistory[]
  
  @@map("stores")
}

// ë§¤ì¥-ê³ ê° ê´€ê³„
model StoreStakeholder {
  id              Int       @id @default(autoincrement())
  storeId         Int       @map("store_id")
  customerId      Int       @map("customer_id")
  role            String    @default("contract_party") // owner, contract_party, manager
  isBilling       Boolean   @default(true) @map("is_billing") // ì²­êµ¬ ëŒ€ìƒ
  
  store           Store     @relation(fields: [storeId], references: [id], onDelete: Cascade)
  customer        Customer  @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  @@unique([storeId, customerId])
  @@map("store_stakeholders")
}

// ìƒí’ˆ ì¹´í…Œê³ ë¦¬
model ProductCategory {
  id              Int       @id @default(autoincrement())
  name            String
  parentId        Int?      @map("parent_id")
  level           Int       // 1: ëŒ€, 2: ì¤‘, 3: ì†Œ
  
  products        Product[]
  
  @@map("product_categories")
}

// ìƒí’ˆ
model Product {
  id              Int       @id @default(autoincrement())
  categoryId      Int       @map("category_id")
  name            String
  basePrice       Decimal   @map("base_price") @db.Decimal(10, 2)
  unit            String    @default("ê±´")
  
  category        ProductCategory @relation(fields: [categoryId], references: [id])
  orderItems      OrderItem[]
  
  @@map("products")
}

// ì£¼ë¬¸
model Order {
  id              Int       @id @default(autoincrement())
  orderNumber     String    @unique @map("order_number")
  customerId      Int       @map("customer_id")
  storeId         Int?      @map("store_id")
  
  orderType       String    @default("order") // quote, order
  status          String    @default("draft") // draft, confirmed, in_progress, completed
  
  subtotal        Decimal   @db.Decimal(10, 2)
  taxAmount       Decimal   @map("tax_amount") @db.Decimal(10, 2)
  totalAmount     Decimal   @map("total_amount") @db.Decimal(10, 2)
  
  orderDate       DateTime  @map("order_date")
  startDate       DateTime? @map("start_date")
  endDate         DateTime? @map("end_date")
  
  notes           String?
  
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  
  customer        Customer  @relation(fields: [customerId], references: [id])
  store           Store?    @relation(fields: [storeId], references: [id])
  items           OrderItem[]
  purchaseOrders  PurchaseOrder[]
  invoices        Invoice[]
  
  @@map("orders")
}

// ì£¼ë¬¸ í•­ëª©
model OrderItem {
  id              Int       @id @default(autoincrement())
  orderId         Int       @map("order_id")
  productId       Int       @map("product_id")
  productName     String    @map("product_name")
  quantity        Int
  unitPrice       Decimal   @map("unit_price") @db.Decimal(10, 2)
  subtotal        Decimal   @db.Decimal(10, 2)
  
  order           Order     @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product         Product   @relation(fields: [productId], references: [id])
  
  @@map("order_items")
}

// ê±°ë˜ì²˜
model Supplier {
  id              Int       @id @default(autoincrement())
  name            String
  phone           String?
  email           String?
  notes           String?
  
  createdAt       DateTime  @default(now()) @map("created_at")
  
  purchaseOrders  PurchaseOrder[]
  
  @@map("suppliers")
}

// êµ¬ë§¤ ë°œì£¼
model PurchaseOrder {
  id              Int       @id @default(autoincrement())
  poNumber        String    @unique @map("po_number")
  orderId         Int?      @map("order_id") // ì—°ê²°ëœ íŒë§¤ ì£¼ë¬¸
  supplierId      Int       @map("supplier_id")
  storeId         Int?      @map("store_id")
  
  totalAmount     Decimal   @map("total_amount") @db.Decimal(10, 2)
  status          String    @default("draft")
  
  poDate          DateTime  @map("po_date")
  notes           String?
  
  createdAt       DateTime  @default(now()) @map("created_at")
  
  order           Order?    @relation(fields: [orderId], references: [id])
  supplier        Supplier  @relation(fields: [supplierId], references: [id])
  
  @@map("purchase_orders")
}

// ê³„ì‚°ì„œ
model Invoice {
  id              Int       @id @default(autoincrement())
  invoiceNumber   String    @unique @map("invoice_number")
  orderId         Int       @map("order_id")
  customerId      Int       @map("customer_id")
  
  supplyAmount    Decimal   @map("supply_amount") @db.Decimal(10, 2)
  taxAmount       Decimal   @map("tax_amount") @db.Decimal(10, 2)
  totalAmount     Decimal   @map("total_amount") @db.Decimal(10, 2)
  
  issueDate       DateTime  @map("issue_date")
  status          String    @default("unpaid") // unpaid, paid
  
  createdAt       DateTime  @default(now()) @map("created_at")
  
  order           Order     @relation(fields: [orderId], references: [id])
  payments        Payment[]
  
  @@map("invoices")
}

// ì…ê¸ˆ
model Payment {
  id              Int       @id @default(autoincrement())
  invoiceId       Int?      @map("invoice_id")
  customerId      Int       @map("customer_id")
  
  paymentDate     DateTime  @map("payment_date")
  amount          Decimal   @db.Decimal(10, 2)
  depositorName   String?   @map("depositor_name")
  notes           String?
  
  createdAt       DateTime  @default(now()) @map("created_at")
  
  invoice         Invoice?  @relation(fields: [invoiceId], references: [id])
  
  @@map("payments")
}

// ì‘ì—… íˆìŠ¤í† ë¦¬
model WorkHistory {
  id              Int       @id @default(autoincrement())
  storeId         Int       @map("store_id")
  orderId         Int?      @map("order_id")
  
  workDate        DateTime  @map("work_date")
  workType        String    @map("work_type") // ë¸”ë¡œê·¸, ë¦¬ë·°, ê´‘ê³  ë“±
  workDetail      String    @map("work_detail")
  workCount       Int       @default(1) @map("work_count")
  
  notes           String?
  
  createdAt       DateTime  @default(now()) @map("created_at")
  
  store           Store     @relation(fields: [storeId], references: [id], onDelete: Cascade)
  
  @@map("work_history")
}
```

ë§ˆì´ê·¸ë ˆì´ì…˜:
```bash
npx prisma migrate dev --name init
npx prisma generate
```

Prisma Client ì„¤ì • `src/lib/db.ts`:
```typescript
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: ['error', 'warn'],
  })

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma
```

**ì™„ë£Œ ê¸°ì¤€**:
- [ ] ëª¨ë“  í…Œì´ë¸” ìƒì„± í™•ì¸
- [ ] Prisma Studioì—ì„œ í™•ì¸: `npx prisma studio`

---

### Phase 1-2: ê³ ê° ê´€ë¦¬

#### API êµ¬í˜„

`src/app/api/customers/route.ts`:
```typescript
import { NextRequest } from 'next/server'
import { z } from 'zod'
import { prisma } from '@/lib/db'

const customerSchema = z.object({
  name: z.string().min(1),
  businessNumber: z.string().optional(),
  phone: z.string().optional(),
  email: z.string().email().optional().or(z.literal('')),
  address: z.string().optional(),
  notes: z.string().optional(),
})

// ëª©ë¡ ì¡°íšŒ
export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url)
    const search = searchParams.get('search')

    const customers = await prisma.customer.findMany({
      where: search
        ? {
            OR: [
              { name: { contains: search } },
              { businessNumber: { contains: search } },
              { phone: { contains: search } },
            ],
          }
        : undefined,
      include: {
        _count: {
          select: { orders: true, stores: true },
        },
      },
      orderBy: { createdAt: 'desc' },
    })

    return Response.json(customers)
  } catch (error) {
    console.error('Get customers error:', error)
    return Response.json({ error: 'Failed to fetch customers' }, { status: 500 })
  }
}

// ìƒì„±
export async function POST(req: NextRequest) {
  try {
    const body = await req.json()
    const data = customerSchema.parse(body)

    const customer = await prisma.customer.create({
      data,
    })

    return Response.json(customer)
  } catch (error) {
    if (error instanceof z.ZodError) {
      return Response.json({ errors: error.errors }, { status: 400 })
    }
    console.error('Create customer error:', error)
    return Response.json({ error: 'Failed to create customer' }, { status: 500 })
  }
}
```

`src/app/api/customers/[id]/route.ts`:
```typescript
import { NextRequest } from 'next/server'
import { z } from 'zod'
import { prisma } from '@/lib/db'

const customerSchema = z.object({
  name: z.string().min(1),
  businessNumber: z.string().optional(),
  phone: z.string().optional(),
  email: z.string().email().optional().or(z.literal('')),
  address: z.string().optional(),
  notes: z.string().optional(),
})

// ìƒì„¸ ì¡°íšŒ
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const customer = await prisma.customer.findUnique({
      where: { id: Number(params.id) },
      include: {
        orders: {
          orderBy: { orderDate: 'desc' },
          take: 10,
        },
        stores: {
          include: {
            store: true,
          },
        },
      },
    })

    if (!customer) {
      return Response.json({ error: 'Customer not found' }, { status: 404 })
    }

    return Response.json(customer)
  } catch (error) {
    return Response.json({ error: 'Failed to fetch customer' }, { status: 500 })
  }
}

// ìˆ˜ì •
export async function PUT(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const body = await req.json()
    const data = customerSchema.parse(body)

    const customer = await prisma.customer.update({
      where: { id: Number(params.id) },
      data,
    })

    return Response.json(customer)
  } catch (error) {
    if (error instanceof z.ZodError) {
      return Response.json({ errors: error.errors }, { status: 400 })
    }
    return Response.json({ error: 'Failed to update customer' }, { status: 500 })
  }
}

// ì‚­ì œ
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    await prisma.customer.delete({
      where: { id: Number(params.id) },
    })

    return Response.json({ message: 'Customer deleted' })
  } catch (error) {
    return Response.json({ error: 'Failed to delete customer' }, { status: 500 })
  }
}
```

#### í”„ë¡ íŠ¸ì—”ë“œ í˜ì´ì§€

`src/app/(dashboard)/customers/page.tsx`:
```typescript
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table'

interface Customer {
  id: number
  name: string
  businessNumber?: string
  phone?: string
  _count: {
    orders: number
    stores: number
  }
}

export default function CustomersPage() {
  const router = useRouter()
  const [customers, setCustomers] = useState<Customer[]>([])
  const [search, setSearch] = useState('')
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    fetchCustomers()
  }, [])

  async function fetchCustomers() {
    try {
      const params = new URLSearchParams()
      if (search) params.set('search', search)

      const res = await fetch(`/api/customers?${params}`)
      const data = await res.json()
      setCustomers(data)
    } catch (error) {
      console.error('Failed to fetch customers:', error)
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h1 className="text-3xl font-bold">ê³ ê° ê´€ë¦¬</h1>
        <Button onClick={() => router.push('/customers/new')}>
          + ìƒˆ ê³ ê°
        </Button>
      </div>

      <div className="flex gap-2">
        <Input
          placeholder="ê³ ê°ëª…, ì‚¬ì—…ìë²ˆí˜¸, ì—°ë½ì²˜ ê²€ìƒ‰"
          value={search}
          onChange={(e) => setSearch(e.target.value)}
          onKeyDown={(e) => e.key === 'Enter' && fetchCustomers()}
        />
        <Button onClick={fetchCustomers}>ê²€ìƒ‰</Button>
      </div>

      {loading ? (
        <div>ë¡œë”©ì¤‘...</div>
      ) : (
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>ì´ë¦„</TableHead>
              <TableHead>ì‚¬ì—…ìë²ˆí˜¸</TableHead>
              <TableHead>ì—°ë½ì²˜</TableHead>
              <TableHead>ë§¤ì¥ ìˆ˜</TableHead>
              <TableHead>ì£¼ë¬¸ ìˆ˜</TableHead>
              <TableHead>ì•¡ì…˜</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {customers.map((customer) => (
              <TableRow key={customer.id}>
                <TableCell>{customer.name}</TableCell>
                <TableCell>{customer.businessNumber || '-'}</TableCell>
                <TableCell>{customer.phone || '-'}</TableCell>
                <TableCell>{customer._count.stores}</TableCell>
                <TableCell>{customer._count.orders}</TableCell>
                <TableCell>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => router.push(`/customers/${customer.id}`)}
                  >
                    ìƒì„¸
                  </Button>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      )}
    </div>
  )
}
```

`src/app/(dashboard)/customers/new/page.tsx`:
```typescript
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Textarea } from '@/components/ui/textarea'

export default function NewCustomerPage() {
  const router = useRouter()
  const [loading, setLoading] = useState(false)
  const [formData, setFormData] = useState({
    name: '',
    businessNumber: '',
    phone: '',
    email: '',
    address: '',
    notes: '',
  })

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault()
    setLoading(true)

    try {
      const res = await fetch('/api/customers', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData),
      })

      if (!res.ok) throw new Error('Failed to create customer')

      router.push('/customers')
    } catch (error) {
      console.error(error)
      alert('ê³ ê° ë“±ë¡ ì‹¤íŒ¨')
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="max-w-2xl space-y-6">
      <h1 className="text-3xl font-bold">ìƒˆ ê³ ê° ë“±ë¡</h1>

      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <Label htmlFor="name">ê³ ê°ëª… *</Label>
          <Input
            id="name"
            required
            value={formData.name}
            onChange={(e) => setFormData({ ...formData, name: e.target.value })}
          />
        </div>

        <div>
          <Label htmlFor="businessNumber">ì‚¬ì—…ìë²ˆí˜¸</Label>
          <Input
            id="businessNumber"
            placeholder="000-00-00000"
            value={formData.businessNumber}
            onChange={(e) =>
              setFormData({ ...formData, businessNumber: e.target.value })
            }
          />
        </div>

        <div>
          <Label htmlFor="phone">ì—°ë½ì²˜</Label>
          <Input
            id="phone"
            type="tel"
            placeholder="010-0000-0000"
            value={formData.phone}
            onChange={(e) => setFormData({ ...formData, phone: e.target.value })}
          />
        </div>

        <div>
          <Label htmlFor="email">ì´ë©”ì¼</Label>
          <Input
            id="email"
            type="email"
            value={formData.email}
            onChange={(e) => setFormData({ ...formData, email: e.target.value })}
          />
        </div>

        <div>
          <Label htmlFor="address">ì£¼ì†Œ</Label>
          <Input
            id="address"
            value={formData.address}
            onChange={(e) =>
              setFormData({ ...formData, address: e.target.value })
            }
          />
        </div>

        <div>
          <Label htmlFor="notes">ë©”ëª¨</Label>
          <Textarea
            id="notes"
            rows={3}
            value={formData.notes}
            onChange={(e) => setFormData({ ...formData, notes: e.target.value })}
          />
        </div>

        <div className="flex gap-2">
          <Button type="submit" disabled={loading}>
            {loading ? 'ë“±ë¡ ì¤‘...' : 'ë“±ë¡'}
          </Button>
          <Button
            type="button"
            variant="outline"
            onClick={() => router.back()}
          >
            ì·¨ì†Œ
          </Button>
        </div>
      </form>
    </div>
  )
}
```

**ì™„ë£Œ ê¸°ì¤€**:
- [ ] ê³ ê° ëª©ë¡ ì¡°íšŒ
- [ ] ê³ ê° ë“±ë¡
- [ ] ê³ ê° ìƒì„¸/ìˆ˜ì •/ì‚­ì œ

**ìë™ ì§„í–‰**: Phase 1-3ìœ¼ë¡œ

---

### Phase 1-3 ~ 1-9: ë‚˜ë¨¸ì§€ ê¸°ëŠ¥

**ê°™ì€ íŒ¨í„´ìœ¼ë¡œ êµ¬í˜„**:
- ë§¤ì¥ ê´€ë¦¬ (ê³ ê°ê³¼ ë™ì¼í•œ CRUD)
- ìƒí’ˆ ê´€ë¦¬ (ì¹´í…Œê³ ë¦¬ + ìƒí’ˆ)
- ì£¼ë¬¸ ê´€ë¦¬ (ê²¬ì ì„œ PDF ìƒì„± í¬í•¨)
- êµ¬ë§¤ ê´€ë¦¬ (ê±°ë˜ì²˜ + ë°œì£¼)
- ì •ì‚° ê´€ë¦¬ (ê³„ì‚°ì„œ + ì…ê¸ˆ ë§¤ì¹­)
- ì‘ì—… íˆìŠ¤í† ë¦¬ (ë§¤ì¥ë³„ ì‘ì—… ê¸°ë¡)
- ëŒ€ì‹œë³´ë“œ (ì°¨íŠ¸ + í†µê³„)

---

## ğŸ¯ ê°„ì†Œí™” í¬ì¸íŠ¸

### 1. ì¸ì¦ ì´ˆê°„ë‹¨í™”
```typescript
// ë³µì¡í•œ JWT ëŒ€ì‹ 
localStorage.setItem('authenticated', 'true')

// ë˜ëŠ” í™˜ê²½ë³€ìˆ˜ ë¹„ë°€ë²ˆí˜¸
if (password === process.env.ADMIN_PASSWORD) { ... }
```

### 2. í¬ë¡¤ë§ ì œì™¸
- Phase 1: ìˆ˜ë™ ì…ë ¥ë§Œ
- Phase 2: í¬ë¡¤ë§ ì¶”ê°€

### 3. ì•Œë¦¼ ìµœì†Œí™”
- Phase 1: í™”ë©´ìƒ ì•Œë¦¼ë§Œ
- Phase 2: ì¹´ì¹´ì˜¤í†¡/ì´ë©”ì¼

### 4. ë³´ê³ ì„œ ê°„ì†Œí™”
- Phase 1: ê¸°ë³¸ ëŒ€ì‹œë³´ë“œë§Œ
- Phase 2: ìƒì„¸ ë¦¬í¬íŠ¸

---

## âœ… ì™„ë£Œ ì²´í¬ë¦¬ìŠ¤íŠ¸

### Phase 0 ì™„ë£Œ
- [ ] í”„ë¡œì íŠ¸ ìƒì„±
- [ ] ê°„ë‹¨í•œ ë¡œê·¸ì¸

### Phase 1 ì™„ë£Œ
- [ ] ê³ ê° CRUD
- [ ] ë§¤ì¥ CRUD
- [ ] ìƒí’ˆ CRUD
- [ ] ì£¼ë¬¸ ìƒì„± + ê²¬ì ì„œ PDF
- [ ] êµ¬ë§¤ ë°œì£¼
- [ ] ê³„ì‚°ì„œ ë°œí–‰ + ì…ê¸ˆ ê´€ë¦¬
- [ ] ì‘ì—… íˆìŠ¤í† ë¦¬
- [ ] ëŒ€ì‹œë³´ë“œ (ì¼/ì£¼/ì›”/ë¶„ê¸°/ì—° ë§¤ì¶œ)

---

## ğŸš€ ì‹œì‘ ëª…ë ¹

```
Phase 0-1ë¶€í„° ì‹œì‘í•©ë‹ˆë‹¤.
í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•˜ê³  ê°„ë‹¨í•œ ë¡œê·¸ì¸ë¶€í„° êµ¬í˜„í•˜ê² ìŠµë‹ˆë‹¤.
```

**ì˜ˆìƒ ê°œë°œ ì‹œê°„**: 
- Phase 0: 30ë¶„
- Phase 1: 1-2ì£¼ (í•˜ë£¨ 2-3ì‹œê°„ ì‘ì—… ê¸°ì¤€)

---

**ì‹¤ë¬´ ì¤‘ì‹¬ ë§ˆìŠ¤í„° í”„ë¡¬í”„íŠ¸ ë**
